---
layout: post
title:  设 计 原 则
date:   2015-07-11 10:43:11
category: "设计模式"
---
* #[1.六大设计原则](#1) 
* * ##[1.1 单一职责原则](#1.1) 
* * ##[1.2 里氏替换原则](#1.2) 
* * ##[1.3 依赖倒置原则](#1.3)
* * ##[1.4 接口隔离原则](#1.4) 
* * ##[1.5 迪米特原则](#1.5) 
* * ##[1.6 开闭原则](#1.6)
---


<h2 id="1"> 1.六大设计原则</h2> 


<h3 id="1.1"> 1.1 单一职责原则</h3> 

一个类，只有一个引起它变化的原因。应该只有一个职责。每一个职责都是变化的一个轴线，如果一个类有一个以上的职责，这些职责就耦合在了一起。这会导致脆弱的设计。当一个职责发生变化时，可能会影响其它的职责。另外，多个职责耦合在一起，会影响复用性。例如：要实现逻辑和界面的分离。

**问题由来**

	之所以会出现单一职责原则就是因为在软件设计时会出现以下类似场景：
	T负责两个不同的职责：职责P1，职责P2。当由于职责P1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责P2功能发生故障。也就是说职责P1和P2被耦合在了一起。

**产生原因**

	没有任何的程序设计人员不清楚应该写出高内聚低耦合的程序，但是很多耦合常常发生在不经意之间，其原因就是：
	职责扩散：因为某种原因，某一职责被分化为颗粒度更细的多个职责了。

**解决办法**

	遵守单一职责原则，将不同的职责封装到不同的类或模块中。
 
<h3 id="1.2"> 1.2 里氏替换原则</h3> 

里氏替换原则通俗的解释是：父类能出现的地方应该可以被替换成子类，但子类出现的地方不一定可以替换成父类。

**定义**

	If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in term of T , the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T .
	如果对每一个类型为 S 的对象 o1，都有类型为 T 的对象 o2,使得以 T 定义的所有程序 P 在所有的对象 o1 都可以替换成 o2 时，程序 P 的行为没有发生变化，那么类型 S 是类型 T 的子类型。

	Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it .
	所有引用基类的地方必须能够透明地使用其子类的对象。
	
**定义的四层含义**
	
	1. 子类必须完全实现父类的方法
	2. 子类可以有自己的个性
	3. 覆盖或实现父类的方法时输入参数可以被放大
	4. 覆写或实现父类的方法时输出结果可以被缩小
**实例解析**


<h3 id="1.3"> 1.3 依赖倒置原则</h3> 

<h3 id="1.4"> 1.4 接口隔离原则</h3> 
 
<h3 id="1.5"> 1.5 迪米特原则</h3> 

<h3 id="1.6"> 1.6 开闭原则</h3> 
